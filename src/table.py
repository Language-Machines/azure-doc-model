#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
All Rights Reserved
(c) Language Machines Corporation 2023
"""

import logging
import json
from gpt_api import ask, search, lang_model, chat
from collections import defaultdict
from utils.utils import above, not_in, legal_non_empty_string
from pprint import pformat
from converter import Converter

logger = logging.getLogger(__name__)
print(logger)

def coord(cell):
    x = {'i': cell['row_index'], 'j': cell['column_index'], 'v': cell['content']}
    if cell['row_span'] != 1:
        x['i_span'] = cell['row_span']
    if cell['column_span'] != 1:
        x['j_span'] = cell['column_span']
    if cell['kind'] != 'content':
        x['kind'] = cell['kind']
    return x
    
def coords(table):
    return [coord(cell) for cell in table['cells']]

def adjust_col_headers(table):
    headers = col_headers(table)
    num_cols = max(headers.keys())
    header_cells = [coord(cell) for cell in table['cells'] if cell['kind'] == 'columnHeader']
    m = max(c['i'] for c in header_cells)
    # TODO: Make this work for multi-span rows
    next_row = [c for c in table['cells'] if c['row_index'] == m+1 if legal_non_empty_string(c['content'])]
    if len(next_row) == num_cols+1:
        # Possibly a header row extension
        logger.info(f'Extending headers to row {m+1}.')
        for cell in table['cells']:
            if cell['row_index'] == m+1:
                cell['kind'] = 'columnHeader'
    
     
# TODO: Do type-based computation to determine how many columns of row headers exist.
def row_headers(table, n_row_headers=2):
    header_cells = [u for cell in table['cells'] for u in [coord(cell)] if u['j'] < n_row_headers]
    
    headers = defaultdict(list)
    for cell in header_cells:
        i, j, v = cell['i'], cell['j'], cell['v']
        i_span = cell.get('i_span', 1)
        for ii in range(i, i+i_span):
            headers[ii].append((j, v))
    #pprint(headers)
    for j, v in headers.items():
        headers[j] = sorted(v)
        headers[j] = [v for _, v in headers[j]]
        headers[j] = ' '.join(headers[j]).strip()
        headers[j] = headers[j].replace('\n', ' ')
    return headers

def col_headers(table):
    header_cells = [coord(cell) for cell in table['cells'] if cell['kind'] == 'columnHeader']
    
    headers = defaultdict(list)
    for cell in header_cells:
        i, j, v = cell['i'], cell['j'], cell['v']
        j_span = cell.get('j_span', 1)
        for j in range(j, j+j_span):
            headers[j].append((i, v))
    #pprint(headers)
    for i, v in headers.items():
        headers[i] = sorted(v)
        headers[i] = [v for _, v in headers[i]]
        headers[i] = ' '.join(headers[i]).strip()
        headers[i] = headers[i].replace('\n', ' ')
    return headers
    
    
def add_headers(table, force=False, sep=" "):
    if 'header' in table and not force:
        return
    
    p = [x for x in table['page_info'] if x[ 'relative_position_to_table'] == 'above']
    p = sorted(p, key=lambda x: x['line_position'])
    
    above = sep.join([pp['text'] for pp in p])
    
    p = [x for x in table['page_info'] if x[ 'relative_position_to_table'] == 'below']
    p = sorted(p, key=lambda x: x['line_position'])
    below = sep.join([pp['text'] for pp in p])
    
    table['headers'] = {'above': above, 'below': below}
    

def text_from_paras(paras):
    return '\n'.join([p['content'] for p in paras])

 
class Table:
    def __init__(self, vj, section_name, section_facts, biller, row_header_depth=0, hints=None):

        """
        :param vj -- Visual Json generated by Azure from a single page.
        """
        assert len(vj['tables']) == 1
        self.converter = Converter(biller)
        self.row_header_depth = row_header_depth
        self.traverse_across_rows = (row_header_depth==0) # Entities are per row if this is True else they are per column
        self.vj = vj
        
        self.biller = biller
        self.section_name = section_name
        self.section_facts= section_facts[section_name]
        self.hints = hints

        # The prompt for a fact type is the value of fact['prompt'] if 'prompt' is defined in the fact,
        # else fact['field_name']. 
        self.section_facts_from_prompt = {fact['prompt'] if 'prompt' in fact else fact['field_name']: fact 
                                      for fact in self.section_facts}

        self.section_facts_from_fk = {fact['field_key']: fact for fact in self.section_facts}
        self.table = vj['tables'][0]
        if self.traverse_across_rows: 
            adjust_col_headers(self.table)
            self.col_headers = col_headers(self.table)
            self.max_column_header_rows = max(cell['i'] 
                                      for cell in coords(self.table) 
                                      if 'kind' in cell 
                                      if cell['kind'] == 'columnHeader')
        else:
            # TODO: implement adjust_row_headers. Right now toke depth as arg
            self.row_headers = row_headers(self.table, row_header_depth)
            
        self.paras_above_table = [p for p in self.vj['paragraphs'] 
               if above(p['bounding_regions'][0]['polygon'], 
                        self.table['bounding_regions'][0]['polygon'])]
        
        self.paras_below_table = [p for p in self.vj['paragraphs'] 
               if above(self.table['bounding_regions'][0]['polygon'],
                        p['bounding_regions'][0]['polygon'])]
        
    def chat(self, message, history=None, model=None, use_cached_data=False):
        model = model or (self.hints['LLM'] if 'LLM' in self.hints else "gpt-4")
        result = chat(message, history=history, model=model, use_cached_data=use_cached_data, biller=self.biller)
        return result

    def text_above_table(self):
        return text_from_paras(self.paras_above_table)
    
    def text_below_table(self):
        """
        TODO: Check if this is just a page number, remove it.
        """
        return text_from_paras(self.paras_below_table)
    
    def build_col_name_to_fact_name_mapping(self, model=None, use_cached_data=False, map_col_to_fact_name=False):
        # v2 --- choose the best fact name
        assert self.traverse_across_rows

        if hasattr(self, "col_name_mapping") and self.col_name_mapping and use_cached_data:
            # You are rerunning. You already have an answer. No need to execute.
            logger.info("build_col_name_to_fact_name_mapping: Already have answer. Nothing to do on rerun.")
            return
        

        fact_names = '\n'.join([f['prompt'] if 'prompt' in f else f['field_name'] 
                                for f in self.section_facts])
        
        col_names = '\n'.join(self.col_headers.values())
#         prompt = f"""You are given the set of column names in a table, and a set of fact names of interest. Emit a JSON dictionary
# mapping each column name to the (possibly empty) list of all fact names that it could represent.
# --- Preamble
# {self.text_above_table()}
# --- Column Names
# {col_names}
# --- Fact Names
# {fact_names}
# --- JSON result"""
        
        prompt = f"""You are given the set of column names in a table, and a set of fact names of interest. Emit a JSON dictionary
mapping each column name to the fact name that it could represent, if there is one, and JSON null otherwise. 
--- Preamble
{self.text_above_table()}
--- Column Names
{col_names}
--- Fact Names
{fact_names}
--- JSON result"""
        
        """
        We handle this now with the prompt field in fact type. 
        enhanced_map = {
            "Line 20(Z): Section 199A-Qualified Business Income (Loss)": "Line 20(Z): Section 199A-Qualified Business Income"
        }
        """
        prompt = f"""You are given the set of column names in a table, and a set of fact names of interest. Emit a JSON dictionary
mapping each fact name to the column name that could contain its data, if there is one, and JSON null otherwise. 
--- Preamble
{self.text_above_table()}
--- Column Names
{col_names}
--- Fact Names
{fact_names}
--- JSON result"""

        prompt = f"""You are an assistant helping an accountant prepare a K-1/K-3 tax return.
Below you are given the list of column names in the table containing {self.section_name} information.
You are also given the list of fact names of interest. The information needed to generate a fact
name may be contained in a column.

Emit a JSON dictionary mapping each fact name to the column name that could contain its data, if there is one, and JSON null otherwise. 
--- Preamble to the table in {self.section_name}
{self.text_above_table()}
--- Column Names in {self.section_name}
{col_names}
--- Fact Names of interest for {self.section_name}
{fact_names}
--- JSON result"""

        logger.debug(f"col_name_mapping prompt: {prompt}")
        u=self.chat(prompt, model=model, use_cached_data=False)
        u = json.loads(u['choices'][0]['message']['content'])
        fn_to_fk = defaultdict(list)
        for k, v  in u.items():
            if v is not None:
                # k = enhanced_map[k] if k in enhanced_map else k
                fn_to_fk[v].append(k)
        self.col_name_mapping= fn_to_fk
        
        logger.debug(f"col_name_mapping: {pformat(fn_to_fk, indent=4,width=120)}")
        
        #u=chat(prompt, model=model)
        #self.col_name_mapping=json.loads(u['choices'][0]['message']['content'])
        # TODO: check for non-well formed json
    

    def build_row_name_to_fact_name_mapping(self, model="gpt-4", force=False, use_cached_data=False):
        assert not self.traverse_across_rows
        if hasattr(self, "row_name_mapping") and self.row_name_mapping and not force:
            return
        fact_names = '\n'.join([f['field_name'] for f in self.section_facts])
        row_names = '\n'.join(self.row_headers.values())
        prompt = f"""You are given the set of row names in a table, and a set of fact names of interest. Emit a JSON dictionary
mapping each row name to the (possibly empty) list of all fact names that it could represent.
--- Preamble
{self.text_above_table()}
--- Row Names
{row_names}
--- Fact Names
{fact_names}
--- JSON result"""
        
        prompt = f"""You are given the set of row names in a table, and a set of fact names of interest. Emit a JSON dictionary
mapping each fact name to the row name that could contain its data, if there is one, and JSON null otherwise. 
--- Preamble
{self.text_above_table()}
--- Row Names
{row_names}
--- Fact Names
{fact_names}
--- JSON result"""

        u = self.chat(prompt, model=model, use_cached_data=use_cached_data)
        u = json.loads(u['choices'][0]['message']['content'])
        fn_to_fk = defaultdict(list)
        for k, v  in u.items():
            if v is not None:
                fn_to_fk[v].append(k)
        self.row_name_mapping= fn_to_fk
        # TODO: check for non-well formed json
        
    def build_headers_to_fact_name_mapping(self, model=None, force=False, use_cached_data=False):
        if self.traverse_across_rows:
            self.build_col_name_to_fact_name_mapping(model=model, force=force, use_cached_data=use_cached_data)
        else: 
            self.build_row_name_to_fact_name_mapping(model=model, force=force, use_cached_data=use_cached_data)
            
    def gen_facts(self,use_cached_data=False, model=None):
        err = f"Ensure that self.build_headers_to_fact_name_mapping() has been called."
        assert self.col_name_mapping if self.traverse_across_rows else self.row_name_mapping, err
        facts = []
        table_cells = coords(self.table)
        if self.traverse_across_rows:
            for cell in table_cells:
                if 'kind' in cell and cell['kind'] == 'columnHeader':
                        continue
                i, j, v = cell['i'], cell['j'], cell['v']
                i = i - (self.max_column_header_rows + 1) # 0-based
                assert i >= 0
                col_header = self.col_headers[j]
                prompts = self.col_name_mapping[col_header]
                for prompt in prompts: 
                    if prompt not in self.section_facts_from_prompt:
                        logger.warn(f"Huh? prompt {prompt} is not known to section_facts.")
                        continue
                    fact_type = self.section_facts_from_prompt[prompt]
                    fact = self.converter.apply_conversion(fact_type, v, use_cached_data)
                    fact['column'] = i # we still call it column
                    logger.debug(f"{prompt} col: {i}, orig: {fact['value']}, converted: {fact['converted_value']}")
                    
                    facts.append(fact)
        else: # Traversing across columns.
             # TODO: convert this branch to use prompts as well, as the above branch.
             for cell in table_cells:
                #if 'kind' in cell and cell['kind'] == 'columnHeader':
                #    print(f"Ignoring col header {cell}")
                #    continue
                i, j, v = cell['i'], cell['j'], cell['v']
                
                j = j - (self.row_header_depth) # 0-based
                if j < 0:
                    continue
                row_header = self.row_headers[i]
                fact_names = self.row_name_mapping[row_header]
                #print(f"fact_name: {fact_name}")
                for fact_name in fact_names:
                    if fact_name not in self.section_facts_from_prompt:
                        logger.warn(f"Huh? fact name {fact_name} is not known to section_facts.")
                        continue
                    fact_type = self.section_facts_from_prompt[fact_name]
                    fact = self.converter.apply_conversion(fact_type, v)
                    fact['column'] = j # we still call it column
                    
                    logger.debug(f"{fact_name} col: {j}, orig: {fact['value']}, converted: {fact['converted_value']}")
                    facts.append(fact)
            
        return facts
           